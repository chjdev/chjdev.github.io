---
title: Efficient Cardinality Estimation with HyperLogLog
description: An implementation of the HyperLogLog data structure for efficient cardinality estimation in JavaScript.
render: <div id='chart' class='bg-image'></div>
layout: post
---

In this post we'll take a look at HyperLogLog. It is an a probabilistic data structure.

## Cardinality

For example, you want to calculate the top 100 web pages based on unique visitors.

Although rather simple, calculating the cardinality tends to be quite expensive
The memory requirements grow with the cardinality in the dataset.


## Probabilistic Data Structures

That have a trade precision for speed, or cheaper requirements. Fo


## When and Where?

Probabilistic data strutures are very<br/>
*specific* mechanism with<br/>
*specific* draw backs and advantages for<br/>
*specific* use cases!

They usually only make sense when you have high requirements on speed and/or volume.
The volume problem can be easily solved via technologies like MapReduce

However when speed is important, specifically with (near) real time requirements
one needs to trade

## HyperLogLog

### General Idea

Although the mathematical reasoning behind it is a little bit intricate, the
core idea of HyperLogLog is actually quite intuitive. It is based on patterns
in a datum

The easiest way to understand it is a slightly different view of the data (without loss of
generality). Let's say the values are viewed as random natural numbers instead of
randomized bit vectors, e.g.:

``0010110101001001``
``0010110101001001``
``0010110101001001``
``0000000000000000``
``0111111111111111``

The chance to hit a low rank number is very high, e.g. for ``rank(n) == 1`` (i.e. no leading zero)
the chance to hit a number is $$ 2^{15} / 2^{16} = 50\% $$. however to find one of ``rank(n) == 15``
only 1 number is possible, i.e. ``1 = 0b0000000000000001``, so the chance to hit that number is
$$ 1 / 2^{16} = 0.0015\% $$.

This is the key observation, the higher the ranks are that you observe the higher the cardinality
has to be in order to have enough chances to find it!

Using only this one estimation is very crude however
You split your observation into multiple estimators and base the calculation on a mean value of
them, more on that in the Implementation.

Now, as I said that example was just a special case. The hashes really are randomly set bitvectors
and you can use whatever pattern you want for your rank implementation. However, the shown one is
easy to implement and used by the authors.  


### Algorithm



The full ECMAScript code can be found
[here](/assets/2016/01/hll.es) and [here](/assets/2016/01/hll_worker.es) or viewed directly on
[Github](https://github.com/chjdev/chjdev.github.io/tree/master/assets/2016/01/).
A transpiled version using [Babel](https://babeljs.io) can be found
[here](/assets/2016/01/hll.js) and [here](/assets/2016/01/hll_worker.js)

<style>
.value { 
    stroke: steelblue;
    stroke-width: 2;
    fill: none;
}
.throughput { 
    stroke: none;
    fill: lightgrey;
    opacity: 0.3;
}
.gold { 
    stroke: red;
    stroke-width: 2;
    fill: none;
}
.stderror { 
    stroke: none;
    fill: steelblue;
    opacity: 0.2
}

.axis path,
.axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
}
</style>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>
const margin = {top: 30, right: 90, bottom: 50, left: 90},
    aspect = Math.sqrt(2),
    raw_width = 1024,
    raw_height = raw_width / aspect,
    width = raw_width - margin.left - margin.right,
    height = raw_height - margin.top - margin.bottom;

const x = d3.scale.linear().range([0, width]),
      left = d3.scale.linear().range([height, 0]),
      right = d3.scale.linear().range([height, 0]);

const xAxis = d3.svg.axis().scale(x).orient("bottom").ticks(10).tickFormat(d3.format("s")),
      leftAxis = d3.svg.axis().scale(left).orient("left").ticks(20).tickFormat(d3.format("s")),
      rightAxis = d3.svg.axis().scale(right).orient("right").ticks(20).tickFormat(d3.format("s"));

const throughput = d3.svg.area()
          .x((d) => x(d[0]))
          .y0((d) => left(d[3]))
          .y1((d) => left(0))
      stderrorarea = d3.svg.area()
          .x((d) => x(d[0]))
          .y0((d) => right(1.04 * d[2]))
          .y1((d) => right(0.96 * d[2]))
          .interpolate('monotone'),
      valueline = d3.svg.line()
          .x((d) => x(d[0]))
          .y((d) => right(d[1]))
          .interpolate('monotone'),
      goldline = d3.svg.line()
          .x((d) => x(d[0]))
          .y((d) => right(d[2]))
           .interpolate('monotone');


function initGraph() {    
    var svg = d3.selectAll("#chart")
        .append("svg")
            .attr("width", raw_width)
            .attr("height", raw_height)
        .append("g")
            .attr("transform", 
                  "translate(" + margin.left + "," + margin.top + ")");
    
    data = [];
    // Scale the range of the data
    //x.domain(d3.extent(data, function(d) { return d.date; }));
    //y.domain([0, d3.max(data, function(d) { return d.close; })]);
    
    svg.append("path")
        .attr("class", "area throughput")
        .attr("d", throughput(data));
    svg.append("path")
        .attr("class", "line value")
        .attr("d", valueline(data));
    svg.append("path")
        .attr("class", "line gold")
        .attr("d", goldline(data));
    svg.append("path")
        .attr("class", "area stderror")
        .attr("d", stderrorarea(data));
    
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);
    svg.append("text")
        .attr("transform", "translate(" + (width / 2) + " ," + height + ")")
        .attr("dy", margin.bottom)
        .style("text-anchor", "middle")
        .style("font-size", "1.5rem")
        .text("# Visists");
    svg.append("g")
        .attr("class", "y left axis")
        .call(leftAxis);
    svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0)
        .attr("x", 0 - (height / 2))
        .attr("dy", -margin.left * 2/3)
        .style("text-anchor", "middle")
        .style("font-size", "1.5rem")
        .text("Throughput (# Visits / second)");
    svg.append("g")
        .attr("class", "y right axis")
        .attr("transform", "translate(" + width + ",0)")
        .call(rightAxis);
    svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", width)
        .attr("x", 0 - (height / 2))
        .attr("dy", margin.left * 4/5)
        .style("text-anchor", "middle")
        .style("font-size", "1.5rem")
        .text("Cardinality");
    svg.append("rect")
        .attr("transform", "translate(" + (width - margin.right) + ", " +  height + ")")
        .attr("x", "-1.4em")
        .attr("y", "-4.9em")
        .attr("width", "1em")
        .attr("height", "1em")
        .style("stroke", "none")
        .style("stroke", "black")
        .style("fill", "steelblue"); //todo class
    svg.append("text")
        .attr("transform", "translate(" + width + " ," + height + ")")
        .attr("dy", "-4em")
        .attr("dx", -margin.right)
        .style("text-anchor", "start")
        .text("Estimate");
    svg.append("rect")
        .attr("transform", "translate(" + (width - margin.right) + ", " +  height + ")")
        .attr("x", "-1.4em")
        .attr("y", "-3.4em")
        .attr("width", "1em")
        .attr("height", "1em")
        .style("stroke", "none")
        .style("stroke", "black")
        .style("fill", "red"); //todo class
    svg.append("text")
        .attr("transform", "translate(" + width + " ," + height + ")")
        .attr("dy", "-2.5em")
        .attr("dx", -margin.right)
        .style("text-anchor", "start")
        .text("Actual");
    svg.append("rect")
        .attr("transform", "translate(" + (width - margin.right) + ", " +  height + ")")
        .attr("x", "-1.4em")
        .attr("y", "-1.9em")
        .attr("width", "1em")
        .attr("height", "1em")
        .style("stroke", "black")
        .style("fill", "lightgrey"); //todo class
    svg.append("text")
        .attr("transform", "translate(" + width + " ," + height + ")")
        .attr("dy", "-1em")
        .attr("dx", -margin.right)
        .style("text-anchor", "start")
        .text("Throughput");

}

function updateGraph() {
    if (typeof data == 'undefined' || data.length == 0) return;
    x.domain([0, data.slice(-1)[0][0]]);
    right.domain([0, 1.04 * data.slice(-1)[0][2]]);
    left.domain([0, d3.max(data, (d) => d[3])]);

    var svg = d3.selectAll("#chart").transition();
    svg.select(".x.axis") // change the x axis
        .duration(750)
        .call(xAxis);
    svg.select(".left.axis") // change the y axis
        .duration(750)
        .call(leftAxis);
    svg.select(".right.axis") // change the y axis
        .duration(750)
        .call(rightAxis);
    svg.select(".line.value")
        .attr("d", valueline(data));
    svg.select(".line.gold")
        .attr("d", goldline(data));
    svg.select(".area.stderror")
        .attr("d", stderrorarea(data));
    svg.select(".area.throughput")
        .attr("d", throughput(data));
}

window.onload = initGraph

const worker = new Worker('/assets/2016/01/hll_worker.js');
worker.addEventListener('message', function(e) {
    data.push(e.data);
}, false);

window.setInterval(updateGraph, 1000);
</script>
<button name='stop' onclick='worker.terminate();'>stop</button>
<button name='start' onclick='worker.postMessage("start");'>start</button>



